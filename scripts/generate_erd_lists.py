#!/usr/bin/env python3
"""
Script to generate erd_lists.h from appliance_api_erd_definitions.json

This script reads the ERD definitions from the public-appliance-api-documentation
library and generates a C header file with ERD lists organized by appliance type.
"""

import json
import sys
from pathlib import Path
from typing import Dict, List, Set


def parse_erd_id(erd_id_str: str) -> int:
    """Convert ERD ID string (e.g., '0x0001') to integer."""
    return int(erd_id_str, 16)


def categorize_erds(erds: List[Dict]) -> Dict[str, List[int]]:
    """
    Categorize ERDs by hex range into appliance types.
    
    Ranges:
    0x0000 to 0x0FFF: common ERDs (all appliance types)
    0x1000 to 0x1FFF: refrigeration ERDs
    0x2000 to 0x2FFF: laundry ERDs
    0x3000 to 0x3FFF: dishwasher ERDs
    0x4000 to 0x4FFF: waterHeater ERDs
    0x5000 to 0x5FFF: range ERDs (i.e., stoves, cooktops, ovens, etc)
    0x7000 to 0x7FFF: air conditioning ERDs (i.e., mini split, Zoneline, etc)
    0x8000 to 0x8FFF: water filter ERDs
    0x9000 to 0x9FFF: small appliance ERDs (i.e., coffee makers, etc)
    0xD000 to 0xDFFF: energy ERDs (all appliance types)
    """
    categories = {
        'common': set(),
        'refrigeration': set(),
        'laundry': set(),
        'dishWasher': set(),
        'waterHeater': set(),
        'range': set(),
        'airConditioning': set(),
        'waterFilter': set(),
        'smallAppliance': set(),
        'energy': set()
    }
    
    for erd in erds:
        erd_id = parse_erd_id(erd['id'])
        
        if 0x0000 <= erd_id <= 0x0FFF:
            categories['common'].add(erd_id)
        elif 0x1000 <= erd_id <= 0x1FFF:
            categories['refrigeration'].add(erd_id)
        elif 0x2000 <= erd_id <= 0x2FFF:
            categories['laundry'].add(erd_id)
        elif 0x3000 <= erd_id <= 0x3FFF:
            categories['dishWasher'].add(erd_id)
        elif 0x4000 <= erd_id <= 0x4FFF:
            categories['waterHeater'].add(erd_id)
        elif 0x5000 <= erd_id <= 0x5FFF:
            categories['range'].add(erd_id)
        elif 0x7000 <= erd_id <= 0x7FFF:
            categories['airConditioning'].add(erd_id)
        elif 0x8000 <= erd_id <= 0x8FFF:
            categories['waterFilter'].add(erd_id)
        elif 0x9000 <= erd_id <= 0x9FFF:
            categories['smallAppliance'].add(erd_id)
        elif 0xD000 <= erd_id <= 0xDFFF:
            categories['energy'].add(erd_id)
    
    # Convert sets to sorted lists
    return {key: sorted(list(value)) for key, value in categories.items()}


def format_erd_list(erds: List[int], indent: int = 2) -> str:
    """Format a list of ERDs as C array elements."""
    if not erds:
        return ""
    
    lines = []
    indent_str = ' ' * indent
    
    for erd in erds:
        lines.append(f"{indent_str}0x{erd:04x},")
    
    return '\n'.join(lines)


def generate_header(categories: Dict[str, List[int]]) -> str:
    """Generate the complete erd_lists.h header file."""
    header = """/*!
 * @file
 * @brief Erd lists for various appliances
 * 
 * This file is auto-generated from appliance_api_erd_definitions.json
 * Do not edit this file manually. Run scripts/generate_erd_lists.py to regenerate.
 */

#ifndef ERD_LISTS_H
#define ERD_LISTS_H

#include "tiny_erd.h"

"""
    
    # Generate each category
    category_info = [
        ('common', 'commonErds', 'commonErdCount', '0x0000 to 0x0FFF: common ERDs (all appliance types)'),
        ('refrigeration', 'refrigerationErds', 'refrigerationErdCount', '0x1000 to 0x1FFF: refrigeration ERDs'),
        ('laundry', 'laundryErds', 'laundryErdCount', '0x2000 to 0x2FFF: laundry ERDs'),
        ('dishWasher', 'dishWasherErds', 'dishWasherErdCount', '0x3000 to 0x3FFF: dishwasher ERDs'),
        ('waterHeater', 'waterHeaterErds', 'waterHeaterErdCount', '0x4000 to 0x4FFF: waterHeater ERDs'),
        ('range', 'rangeErds', 'rangeErdCount', '0x5000 to 0x5FFF: range ERDs (stoves, cooktops, ovens, etc)'),
        ('airConditioning', 'airConditioningErds', 'airConditioningErdCount', '0x7000 to 0x7FFF: air conditioning ERDs (mini split, Zoneline, etc)'),
        ('waterFilter', 'waterFilterErds', 'waterFilterErdCount', '0x8000 to 0x8FFF: water filter ERDs'),
        ('smallAppliance', 'smallApplianceErds', 'smallApplianceErdCount', '0x9000 to 0x9FFF: small appliance ERDs (coffee makers, etc)'),
        ('energy', 'energyErds', 'energyErdCount', '0xD000 to 0xDFFF: energy ERDs (all appliance types)')
    ]
    
    for category_key, array_name, count_name, description in category_info:
        erds = categories[category_key]
        header += f"// {description}\n"
        header += f"const tiny_erd_t {array_name}[] = {{\n"
        if erds:
            header += format_erd_list(erds)
            header += "\n"
        header += "};\n"
        header += f"const uint16_t {count_name} = sizeof({array_name}) / sizeof({array_name}[0]);\n\n"
    
    # Add the lookup table structure
    header += """typedef struct {
  const tiny_erd_t* erdList;
  uint16_t erdCount;
} applianceTypeToErdListAndCount_t;

const applianceTypeToErdListAndCount_t applianceTypeToErdGroupTranslation[] = {
  { waterHeaterErds, waterHeaterErdCount }, // 0x00 = Water heater
  { laundryErds, laundryErdCount }, // 0x01 = Clothes washer
  { laundryErds, laundryErdCount }, // 0x02 = Clothes dryer
  { refrigerationErds, refrigerationErdCount }, // 0x03 = Refrigerator
  { smallApplianceErds, smallApplianceErdCount }, // 0x04 = Microwave
  { rangeErds, rangeErdCount }, // 0x05 = Advantium
  { dishWasherErds, dishWasherErdCount }, // 0x06 = Dishwasher
  { rangeErds, rangeErdCount }, // 0x07 = Oven
  { rangeErds, rangeErdCount }, // 0x08 = Electric range
  { rangeErds, rangeErdCount }, // 0x09 = Gas range
  { airConditioningErds, airConditioningErdCount }, // 0x0A = Thermostat/RAC
  { rangeErds, rangeErdCount }, // 0x0B = Electric Cooktop
  { rangeErds, rangeErdCount }, // 0x0C = Pizza Oven
  { rangeErds, rangeErdCount }, // 0x0D = Gas Cooktop
  { airConditioningErds, airConditioningErdCount }, // 0x0E = Split / DFS (Duct-Free Split) AC
  { rangeErds, rangeErdCount }, // 0x0F = Hood
  { waterFilterErds, waterFilterErdCount }, // 0x10 = Point of Entry Water Filter
  { rangeErds, rangeErdCount }, // 0x11 = Induction Cooktop
  { refrigerationErds, refrigerationErdCount }, // 0x12 = Delivery Box
  { rangeErds, rangeErdCount }, // 0x13 = Kitchen Hub Vent Hood
  { airConditioningErds, airConditioningErdCount }, // 0x14 = Zoneline/PTAC
  { waterFilterErds, waterFilterErdCount }, // 0x15 = Water Softener
  { airConditioningErds, airConditioningErdCount }, // 0x16 = Portable AC
  { laundryErds, laundryErdCount }, // 0x17 = Combination Washer Dryer
  { refrigerationErds, refrigerationErdCount }, // 0x18 = Dual Zone Wine Chiller
  { refrigerationErds, refrigerationErdCount }, // 0x19 = Beverage Center
  { smallApplianceErds, smallApplianceErdCount }, // 0x1A = Coffee Brewer
  { smallApplianceErds, smallApplianceErdCount }, // 0x1B = Opal Nugget Ice Maker
  { refrigerationErds, refrigerationErdCount }, // 0x1C = In-Home Grower
  { airConditioningErds, airConditioningErdCount }, // 0x1D = Dehumidifer
  { refrigerationErds, refrigerationErdCount }, // 0x1E = Under Counter Ice Maker
  { airConditioningErds, airConditioningErdCount }, // 0x1F = Through Wall AC
  { dishWasherErds, dishWasherErdCount }, // 0x20 = F&P DishDrawer
  { smallApplianceErds, smallApplianceErdCount }, // 0x21 = Espresso Coffee Maker
  { smallApplianceErds, smallApplianceErdCount }, // 0x22 = Toaster Oven
  { airConditioningErds, airConditioningErdCount }, // 0x23 = Zoneline/VTAC
  { airConditioningErds, airConditioningErdCount }, // 0x24 = Central DFS (Duct-Free Split) Controller
  { smallApplianceErds, smallApplianceErdCount }, // 0x25 = BLE Mesh Gateway
  { smallApplianceErds, smallApplianceErdCount }, // 0x26 = Stand Mixer
  { rangeErds, rangeErdCount }, // 0x27 = Fisher & Paykel Cooktop
  { rangeErds, rangeErdCount }, // 0x28 = Fisher & Paykel Cooktop Teppanyaki
  { rangeErds, rangeErdCount }, // 0x29 = Fisher & Paykel Ventilation Downdraft
  { smallApplianceErds, smallApplianceErdCount }, // 0x2A = Smart Plug
  { smallApplianceErds, smallApplianceErdCount }, // 0x2B = Smoker
  { airConditioningErds, airConditioningErdCount }, // 0x2C = Air Handler VRF
  { laundryErds, laundryErdCount }, // 0x2D = Fabric Care Cabinet Closet
  { laundryErds, laundryErdCount }, // 0x2E = Laundry Center
  { rangeErds, rangeErdCount }, // 0x2F = Grill
  { refrigerationErds, refrigerationErdCount }, // 0x30 = Freezer
  { rangeErds, rangeErdCount }, // 0x31 = Warming Drawer
  { smallApplianceErds, smallApplianceErdCount }, // 0x32 = Vacuum Seal Drawer
  { refrigerationErds, refrigerationErdCount }, // 0x33 = Wine Cabinet
  { airConditioningErds, airConditioningErdCount }, // 0x34 = Central AC
  { rangeErds, rangeErdCount }, // 0x35 = Hearth Pizza Oven
  { smallApplianceErds, smallApplianceErdCount }, // 0x36 = Sourdough Starter
};
const uint16_t maximumApplianceType = sizeof(applianceTypeToErdGroupTranslation) / sizeof(applianceTypeToErdGroupTranslation[0]);
#endif
"""
    
    return header


def main():
    """Main entry point for the script."""
    # Determine paths relative to script location
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    
    json_file = repo_root / 'lib' / 'public-appliance-api-documentation' / 'appliance_api_erd_definitions.json'
    output_file = repo_root / 'components' / 'geappliances_bridge' / 'erd_lists.h'
    
    if not json_file.exists():
        print(f"Error: Could not find {json_file}", file=sys.stderr)
        print("Make sure git submodules are initialized: git submodule update --init --recursive", file=sys.stderr)
        sys.exit(1)
    
    # Read and parse JSON
    print(f"Reading ERD definitions from {json_file}")
    with open(json_file, 'r') as f:
        data = json.load(f)
    
    erds = data.get('erds', [])
    print(f"Found {len(erds)} ERD definitions")
    
    # Categorize ERDs
    categories = categorize_erds(erds)
    
    # Print statistics
    print("\nERD counts by category:")
    for category, erd_list in categories.items():
        print(f"  {category}: {len(erd_list)}")
    
    # Generate header
    header_content = generate_header(categories)
    
    # Write output
    print(f"\nWriting generated header to {output_file}")
    with open(output_file, 'w') as f:
        f.write(header_content)
    
    print("Done!")


if __name__ == '__main__':
    main()
